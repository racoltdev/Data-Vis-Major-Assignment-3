<!DOCTYPE html>
<html lang='en'>
<head>
	<meta charset="UTF-8">
	<title>Major Assignment 3</title>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
	</style>
</head>

<body>
	<div class="container">
		<svg width="80vw" height="80vh" viewBox="0 0 1200 1000">
		</svg>
	</div>

	<script>
	d3.csv("./data_scopus.csv").then( (data) => {
		let svg = d3.select('svg')
		simulate(data, svg)
	})

	function simulate(data, svg)
	{
		const width = parseInt(svg.attr("viewBox").split(' ')[2])
		const height = parseInt(svg.attr("viewBox").split(' ')[3])
		const color = d3.scaleOrdinal(d3.schemeCategory10);

		// Use a map for nodes for now. data struct conversion indexes by author id often
		nodes = new Map();
		links = [];
		console.log(data);

		// Construct nodes and links
		data.forEach( line => {
			authors = line["Author(s) ID"].split(';');
			// Remove empty last element
			authors.pop();
			affiliations = line["Authors with affiliations"].split(";");
			authors.forEach( (a, index) => {
				// Create dictionary entry for author
				nodes.set(a, {
					"name": line.Authors.split(", ")[index],
					"country": line["Authors with affiliations"].split(", ")[-1]})

				// Generate links, without repeats
				authors.forEach( s => {
					// Sort to make searching for repeats easier
					let author_pair = [a, s].sort();
					const source = author_pair[0];
					const target = author_pair[1];

					link_exists = false;

					links.some( l => {
						// Increment link strength if a repeat
						if (l.source == source && l.target == target) {
							l.strength += 1;
							link_exists = true;
							return true;
						}
						return false;
					})
					if (!link_exists) {
						links.push({"source": author_pair[0], "target": author_pair[1], "strength": 1});
					}
				})

				// If there are any listed affiliations, figure out the country each other is associated with
				if (affiliations) {
					affiliations.some( aff_list => {
						aff_list_split = aff_list.split(", ")
						return aff_list_split.some( aff => {
							if (nodes.get(a).name.includes(aff)) {
								nodes.get(a).country = aff_list_split[aff_list_split.length - 1]
								return true;
							}
							return false;
						})
					})
				}
			})
		})

		// Translate nodes from dict to array so ForceSimulate works
		let node_arr = []
		nodes.forEach( (n, index) => {
			node_arr.push({"name": n.name, "country": n.country});
			// Update the references in links from author id indexing to positional indexing
			links.forEach( l => {
				if (l.source == index) {
					l.source = node_arr.length - 1;
				}
				if (l.target == index) {
					l.target = node_arr.length - 1;
				}
			})
		})
		console.log(node_arr)
		console.log(links)

		// Generate svg elements for each node and link
		const node_elements = svg.append("g")
	        .attr('transform', `translate(${width / 2},${height / 2})`)
	        .selectAll(".circle")
	        .data(node_arr)
	        .enter()
	        .append("circle")
	        .attr("r", 5)
	        .attr("fill", d=>color(d.country))

		const link_elements = svg.append("g")
        	.attr('transform',`translate(${width/2},${height/2})`)
        	.selectAll(".line")
        	.data(links)
        	.enter()
        	.append("line")
        	.style("stroke-width", d => d.strength*1.5)
			.style("stroke-opacity", d => d.strength*0.10);

		// Run the simulation and modify those svg elements
		const ForceSimulation = d3.forceSimulation(node_arr)
    		.force("collide", d3.forceCollide().radius(15))
    		.force("x", d3.forceX())
    		.force("y", d3.forceY())
    		.force("charge", d3.forceManyBody())
    		.force("link", d3.forceLink(links)
    		    .id(d=>d.index)
    		    .distance(d=>d.strength)
    		    .strength(d=>d.strength * .1)
    		)

    		.on("tick", ticked);

    		function ticked()
    		{
				node_elements
    				.attr("cx", d=> d.x)
    		    	.attr("cy", d=> d.y)
				link_elements
    		        .attr("x1",d=>d.source.x)
    		        .attr("x2",d=>d.target.x)
    		        .attr("y1",d=>d.source.y)
    		        .attr("y2",d=>d.target.y)
					.attr("stroke", "#ababab")
    		}
	}

	</script>
</body>
</html>
