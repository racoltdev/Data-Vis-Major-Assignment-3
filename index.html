<!DOCTYPE html>
<html lang='en'>
<head>
	<meta charset="UTF-8">
	<title>Major Assignment 3</title>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<style>
        #tooltip {
            position: absolute;
            opacity: 0;
            top: 0;
            left: 0;
            width: auto;
            padding: 10px;
            background: white;
            font-family: sans-serif;
            font-size: medium;
            border-radius: 2px;
            line-height: 1;
        }

	</style>
</head>

<body>
    <div id="tooltip"></div>
	<div class="container">
		<svg width="80vw" height="80vh" viewBox="0 0 1000 1500">
		</svg>
	</div>

	<script>
	d3.csv("./data_scopus.csv").then( (data) => {
		let svg = d3.select('svg')
		simulate(data, svg)
	})

	function simulate(data, svg)
	{
		const width = parseInt(svg.attr("viewBox").split(' ')[2])
		const height = parseInt(svg.attr("viewBox").split(' ')[3])
		const color = d3.scaleOrdinal(d3.schemeCategory10);

		const [node_arr, links, sorted_countries] = preprocess(data);

		const tooltip = d3.select("#tooltip");

		const link_elements = svg.append("g")
        	.attr('transform',`translate(${width/2},${height/2})`)
        	.selectAll(".line")
        	.data(links)
        	.enter()
        	.append("line")
        	.style("stroke-width", d => d.strength*1.5)
			.style("stroke-opacity", d => d.strength*0.10);

		// Generate svg elements for each node and link
		const node_elements = svg.append("g")
	        .attr('transform', `translate(${width / 2},${height / 2})`)
	        .selectAll(".circle")
	        .data(node_arr)
	        .enter()
	        .append("circle")
	        .attr("r", 5)
			// Only color the 10 most common countries
	        .attr("fill", d=>country_to_color(d.country))

		// Run the simulation and modify those svg elements
		const ForceSimulation = d3.forceSimulation(node_arr)
    		.force("collide", d3.forceCollide().radius(15))
    		.force("x", d3.forceX())
    		.force("y", d3.forceY())
    		.force("charge", d3.forceManyBody())
    		.force("link", d3.forceLink(links)
    		    .id(d=>d.index)
    		    .distance(d=>d.strength)
    		    .strength(d=>d.strength * .1)
    		)
    		.on("tick", ticked);

		const sim_nodes = svg.selectAll("circle")
			.on("click", (m, d) => {
				tooltip.transition()
					.duration(200)
					.style("opacity", .9)
				tooltip.html(d["name"])
					.style("left", m.clientX + "px")
					.style("top", m.clientY + "px");
			})
			.on("mouseenter", function (m, d) {
				d3.select(this)
					.transition()
					.duration(200)
					.attr("r", 8)
					.attr('stroke-width', 2)
					.attr('stroke', "black")
					.attr("stroke-opacity", 0.8);
			})
			.on("mouseleave", function (m, d) {
				d3.select(this)
					.transition()
					.duration(200)
					.attr("r", 5)
					.attr("stroke-width", 0)
					.attr("stroke-opacity", 0)
				tooltip.transition()
					.duration(200)
					.style("opacity", 0)
				tooltip.html("")
					// Move out of the way of nearby nodes
					.style("left", "0px")
					.style('top', "0px")
			})

    	function ticked()
    	{
			node_elements
    			.attr("cx", d=> d.x)
    	    	.attr("cy", d=> d.y)
			link_elements
    	        .attr("x1",d=>d.source.x)
    	        .attr("x2",d=>d.target.x)
    	        .attr("y1",d=>d.source.y)
    	        .attr("y2",d=>d.target.y)
				.attr("stroke", "#ababab")
    	}

		function country_to_color(country) {
			if (countries.has(country)) {
				return color(country);
			}
			else {
				return "#a9a9a9"
			}
		}
	}

	function preprocess(data) {
		// Use a map for nodes for now. data struct conversion indexes by author id often
		nodes = new Map();
		links = [];
		countries = new Map();
		console.log(data);

		// Construct nodes and links
		data.forEach( line => {
			if (!line.Authors) return;
			if (!line.Year) return;
			authors = line["Author(s) ID"].split(';');
			// Remove empty last element
			authors.pop();
			affiliations = line["Authors with affiliations"].split(";");
			authors.forEach( (a, index) => {
				// Create dictionary entry for author
				const name = line.Authors.split(", ")[index];
				const author_map = new Map();
				author_map.set("name", name);
				nodes.set(a, author_map);

				// If there are any listed affiliations, figure out the country each author is associated with
				let affiliation_found = true;
				if (affiliations) {
					affiliations.some( aff_list => {
						aff_list_split = aff_list.split(", ");
						return aff_list_split.some( aff => {
							if (name.includes(aff)) {
								affiliation_found = true;
								let country = aff_list_split[aff_list_split.length - 1];
								nodes.get(a).set("country", country);
								if (countries.has(country)) {
									countries.set(country, countries.get(country) + 1);
								}
								else {
									countries.set(country, 1);
								}
								return true;
							}
							return false;
						})
					})
				}

				if (!affiliation_found) {
					nodes.delete(a);
					return;
				}

				// Generate links, without repeats
				authors.forEach( s => {
					// Sort to make searching for repeats easier
					let author_pair = [a, s].sort();
					const source = author_pair[0];
					const target = author_pair[1];

					link_exists = false;

					links.some( l => {
						// Increment link strength if a repeat
						if (l.source == source && l.target == target) {
							l.strength += 1;
							link_exists = true;
							return true;
						}
						return false;
					})
					if (!link_exists) {
						links.push({"source": author_pair[0], "target": author_pair[1], "strength": 1});
					}
				})

			})
		})

		// Produce list of top 10 most common country affiliations
		const sorted_countries = new Map(
			[...countries.entries()]
			.toSorted((x, y) => y[1] - x[1])
			.slice(0, 10));
		console.log(sorted_countries);

		// Translate nodes from dict to array so ForceSimulate works
		let node_arr = []
		nodes.forEach( (n, index) => {
			node_arr.push({"name": n.get("name"), "country": n.get("country")});
			// Update the references in links from author id indexing to positional indexing
			links.forEach( l => {
				if (l.source == index) {
					l.source = node_arr.length - 1;
				}
				if (l.target == index) {
					l.target = node_arr.length - 1;
				}
			})
		})
		console.log(nodes)
		console.log(links)

		return [node_arr, links, sorted_countries];
	}
	</script>
</body>
</html>
